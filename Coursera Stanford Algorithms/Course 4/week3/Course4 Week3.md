## Course 4 Week 3

这一周主要介绍了有关背包问题的启发式算法，下面回顾下。



### Part 1:A Greedy Knapsack Heuristic    

#### 1.Knapsack Problem

首先回顾下背包问题

输入：n个物体，每个物体都有一个value $v_i$和一个size $w_i$，背包容量是$W$

输出：一个子集$S⊆\{1,2,...,n\}$使得
$$
在条件 \sum_{i\in S}w_i ≤ W下\\
最大化 \sum_{i\in S}v_i
$$



下面介绍一种贪婪式启发，动机是找value较大，但是size较小的物块。

#### 2.A Greedy Heuristic    

步骤 1: 对物体排序使得 $\frac{v_1} {w_1} ≥ \frac{v_2} {w_2} ≥ ... ≥ \frac{v_n}{ w_n}$ [即根据物体的单位价值排序] 。

步骤 2: 按照此顺序选取物体直至无法再选取，然后停止。

这个方法一看就是有点问题的，下面看一个Quiz



##### Quiz

考虑一个$W = 1000$的背包实例:$v_1 = 2,w_1 = 1;v_2 = 1000,w_2 = 1000$。问题：贪婪解决方案和最佳解决方案的价值分别是什么？

A) 2和1000 

B) 2和1002

C) 1000和1002  

D) 1002和1002    

比较简单，贪婪算法会先选择第一个物体，然后就无法放第二个物体了，所以贪婪算法的答案为2，而最优解显然为选取第二个物体，答案为1000。所以这题选A。



从这个问题中，可以看到之前那个贪婪算法很容易找到问题，所以老师对算法加了一个步骤3：

步骤 1: 对物体排序使得 $\frac{v_1} {w_1} ≥ \frac{v_2} {w_2} ≥ ... ≥ \frac{v_n}{ w_n}$ [即根据物体的单位价值排序] 。

步骤 2: 按照此顺序选取物体直至无法再选取，然后停止。

步骤 3: 返回步骤2的解或value最大的一个物体，以较好的为准。

加了这个步骤之后可以避免上述情况，但实际上还是会有点问题，后面会对此继续优化。



#### 3.算法分析    

这一部分对刚刚建立的算法进行分析，分析之前需要给出如下定义。

##### greedy fractional solution 

这里将greedy fractional solution翻译为贪婪算法的分数解。

贪婪算法的分数解的含义是使用之前的算法，在允许背包里的最后一个物体可以装一个百分比（例如70%）乘以物体的重量的条件下的背包问题的最优解。这里说的有点拗口，可以看一个具体例子。

![](https://github.com/Doraemonzzz/md-photo/blob/master/Coursera%20Stanford%20Algorithms/Part4%20np-completeness/week3/2018062201.png?raw=true)



这里来看一个问题

##### Quiz

令$F$=贪婪算法的分数解的最优解，$OPT =$（非分数）的最优解。以下哪一个是真的？
A）对于每个每个背包问题，$F =OPT$ 
B）对于每个每个背包问题，$F> OPT$
C）对于每个每个背包问题，$F≤OPT$，并且不等式可以是严格的
D）对于每个每个背包问题，$F\ge OPT$，并且不等式可以是严格的

这题选D，下面证明这个结论。



##### 结论

贪婪算法的分数解至少和非分数解一样好。

设$S =$任意可行解，现在有一下两种假设:
(a) 假设背包的每一个单元都不是由贪婪算法的分数解填充
(b) 假设背包至少有一个单元是由贪婪算法的分数解填充
通过贪婪算法，(b) 得到的$\frac {w_i}{v_i}$要大于等于 (a) 得到的$\frac {w_i}{v_i}$，贪婪算法的分数解至少和非分数解一样好。



有了上述铺垫，可以给出如下定理：

##### 定理

3步贪婪算法的解的value永远$≥50％$·最优解的value。

证明：在Step 2中，假设我们的贪婪算法选取前$k$个物体（按$\frac {v_i}{w_i}$排序），注意以下两点

(1) 三步贪心算法的值$≥$前$k$项的value

这一点是毫无疑问的，因为Step 3是取Step 2得到的解（前$k$个物体）以及value最大的一个物品中的较大值。

(2) 三步贪心算法的值$≥$第$k+1$项的value

这一点是因为三步贪心算法的值$\ge$value最大的一个物品$\ge$第$k+1$项的value。

将两个不等式相加可得：

2$\times$三步贪心算法的值$≥$前$k$项的value+第$k+1$项的value=前$k+1$项的value

由贪婪算法的分数解的定义以及性质我们知道，前$k+1$项的value$\ge$贪婪算法的分数解的value$\ge$最优解的value，综上
$$
2\times三步贪心算法的值\ge最优解的value
\\三步贪心算法的值 \ge 50\%最优解的value
$$



#### 4.A Dynamic Programming Heuristic    

这里老师要介绍一个动态规划算法，但是由于实数处理起来很困难，所以老师在这里将原问题转化为整数问题，介绍了如下算法。



算法的第1步：

将每个$v_i$减少到$m$的最接近的倍数倍，即$\hat v_i=\lfloor \frac{v_i}{m} \rfloor$（更大的$m$意味着抛出更多的信息，准确性就更低）。

算法的第2步：

使用动态规划解决value为$\hat v_1,...,\hat v_n$，size为$w_1,...,w_n$，背包容量为$W$的背包问题。


这个算法的准确性后续会分析，先考虑如何解决这个简化的问题，即

输入：n个物体，每个物体都有一个value $v_i$和一个size $w_i$，背包容量是$W$，其中$v_i\in Z$(正整数)

输出：一个子集$S⊆\{1,2,...,n\}$使得
$$
在条件 \sum_{i\in S}w_i ≤ W下\\
最大化 \sum_{i\in S}v_i
$$


##### The Subproblems and Recurrence    

Subproblem：对于$i = 0,1,...,n$ 和 $x = 0,...,nv_{max}$，定义$S_{i,x} =$只用前$i$个物体，value大于等于$x$所需要的最小size
（如果不可能，则为$+\infty$）

Recurrence ：
$$
S_{i,x}=min\begin{cases}
S_{i-1,x} & \text{如果第i个问题不在最优解中}\\
w_i+S_{i-1,x-v_i} & \text{如果第i个问题在最优解中}
\end{cases}
$$
注意如果$v_i>x$，那么$S_{i-1,x-v_i}=0$



下面就可以介绍具体的算法了

##### The Algorithm    

令$A$是一个二维数组

[索引为$i=0,1,...n$和$x=0,1,...,nv_{max}$]

基本情形:
$$
A[0,x]=\begin{cases}
0 & \text{如果x=0}\\
+\infty & \text{其余情况}
\end{cases}
$$
对于 $i=1,2,...,n$:

​	对于$x=0,1,...nv_{max}$：
$$
A_{i,x}=min\{A[i-1,x], w_i+A[i-1,x-v_i]\}
$$
返回使得$A[n,x]\le W$的最大的$x$

这里这里一共有$n^2v_{max}$次循环，每次循环的运行时间为$O(1)$，所以运行时间为$O(n^2v_{max})$



#### 5.Analysis of a Dynamic Programming Heuristic for Knapsack    

因为刚刚的算法进行了近似，这里要对算法的准确性进行分析。回顾一下算法的步骤：

Step 1：为每个物体$i$，令$\hat v_i=\lfloor \frac{v_i}{m} \rfloor$
Step 2：用动态规划对$v_i$计算最优解。

这里来看一个Quiz

##### Quiz

假设我们将$v_i$转换为值$\hat{ v_i}$。 以下那个叙述是正确的？
A）$\hat{ v_i}$介于$v_i - m$和$v_i$之间
B）$\hat{ v_i}$介于$v_i$和$v_i + m$之间
C）$m\hat{ v_i}$在$v_i - m$和$v_i$之间
D）$m\hat{ v_i}$在$v_i - 1$和$v_i$之间

由$\lfloor x \rfloor$表示向下取整，所以
$$
x-1\le \lfloor x \rfloor\le x
$$
那么对于$\hat v_i=\lfloor \frac{v_i}{m} \rfloor​$
$$
\frac{v_i}{m}-1\le \hat v_i\le \frac{v_i}{m}\\
v_i-m\le m\hat v_i\le v_i
$$
所以这题选C



##### Accuracy Analysis I    

这里再看一个结论：

如果$S^* $为原始问题的最优解（使用原始的$v_i$），然后$S$为我们的启发式算法的最优解，那么
$$
\sum_{i\in S} \hat v_i\ge \sum_{i\in S^*} \hat v_i
$$

这个结论比较简单，$S$为我们的启发式算法的最优解的定义即可。



结合之前论述，我们把这里的结论总结一下

(1) $v_i\ge m\hat v_i$

(2) $m\hat v_i\ge v_i-m $

(3) 如果$S^* $为原始问题的最优解（使用原始的$v_i$），然后$S$为我们的启发式算法的最优解，那么
$$
\sum_{i\in S} \hat v_i\ge \sum_{i\in S^*} \hat v_i
$$



##### Accuracy Analysis II    

S为我们的解（启发式算法的解），S * 为原始问题的最优解，注意(1),(2),(3)为刚刚列举的规则，那么
$$
\sum_{i\in S}  v_i\overset{(1)}\ge m\sum_{i\in S} \hat v_i\overset{(3)}\ge m\sum_{i\in S^*}  \hat{v_i} \overset{(2)}\ge \sum_{i\in S^*}(v_i-m)
$$
因为最多有n个物体，所以
$$
\sum_{i\in S^*}(v_i-m) \ge (\sum_{i\in S^*}v_i)-mn\\
\sum_{i\in S}  v_i \ge\sum_{i\in S^*}(v_i-m) \ge (\sum_{i\in S^*}v_i)-mn
$$
假设这里有一个常数$\epsilon$，我们选择较小的$m$，使得以下不等式成立
$$
mn\le \epsilon \sum_{i\in S^*}v_i
$$
从而
$$
\sum_{i\in S}  v_i \ge\sum_{i\in S^*}(v_i-m) \ge (\sum_{i\in S^*}v_i)-mn\ge (1-\epsilon)\sum_{i\in S^*}v_i
$$
为了满足关于$mn​$的不等式，我们取$m = \frac {\epsilon v_{max} }{n} ​$，从而
$$
mn=\epsilon v_{max}\le \epsilon\sum_{i\in S^*}v_i
$$
所以在$m = \frac {\epsilon v_{max} }{n} $条件下，我们可以保证$\sum_{i\in S}  v_i \ge (1-\epsilon)\sum_{i\in S^*}v_i$，即启发式算法的解可以在一定程度上接近与最优解。



##### Running Time Analysis 

回顾之前的运行时间$O(n^2v_{max})$，所以这里求$v_{max}$的范围即可。注意我们这里有$m = \frac {\epsilon v_{max} }{n} $以及$\hat v_i\le \frac{v_i}{m}$，从而
$$
\hat v_i\le \frac{v_i}{m}\le \frac{v_{max}}{m}=\frac {v_{max}n}{\epsilon v_{max}}=\frac{n}{\epsilon}
$$
所以运行时间为$O(\frac {n^3}{\epsilon})$



### Part 2:习题

#### 选择题

##### 选择题1

回顾视频演讲中的顶点覆盖问题：给定一个无向图（没有平行边），计算一个最小尺寸的顶点子集，其中包括每个边的至少一个端点。 考虑以下贪婪算法，给出图$G$：

（1）初始化$S =∅$  

（2）当$S$不是$G$的顶点覆盖：

​	（2a）令$F$表示两个端点都不在$S$中边;

 	（2b）令$e$表示$F$的一些边; 

​	（2c）将$e$的两个端点添加到$S$; 

（3）返回$S$。

考虑以下陈述：对于每个具有$n$个顶点的图$G$，该贪婪算法返回一个顶点覆盖，其大小至多为最优（最小尺寸）顶点覆盖的$f（n）$倍。 以下哪一项是函数$f（n）$的最小的正确选择？

[提示：假设贪婪算法选择一个顶点为$u$和$v$的边$e$。 你可以怎样解释这个问题的每一个可行的解决方案？]

A) $2$

B) $O(logn)$

C) $O(\sqrt n)$

D) $O(n)$

在步骤2b中，假设一共选择了$|M|$条边，那么这里贪婪算法一共选择了$2|M|$个点。另外，在2b中，我们选择的是边的两个端点都不在$S$中的边，那么在顶点覆盖问题中，这种边必然要对应一个顶点，所以顶点覆盖问题的最优解的点的个数大于等于$|M|$。所以贪婪算法的解最多为最优解的两倍，选A。



##### 选择题2

在集合覆盖问题中，现在有$m$个集合$S_1，...，S_m$，每一个集合的是一个共同集合$U$的子集，$|U|=n$。现在的目标是尽可能少地选择这些集合，使得这些集合的并集是$U$。（你可以假设$ \bigcup _{i=1}^{m}S_i=U$）例如，如果集合为$\{1,2\}, \{2,3\},\{3,4 \}$，那么最优解由$\{1,2\},\{3,4 \}$组成

这是一个贪婪迭代算法。首先，初始化$C=∅$，$C$表示迄今选择的集合。主要的循环是：只要$\bigcup _{S \in C} S$不是完整的集合$U$：

- 令 $S_i$为最大化$ | S_i - \bigcup_ {S \in C} S |$的$S_i$.
- 加 $S_i$加入到 $C$.

考虑以下陈述：对于集合覆盖问题（$|U|=n$），这个贪心算法返回的解的大小最多为$f （n ）$乘以最优（最小尺寸）集合覆盖。 以下哪一项是函数$f（n）$的最小的正确选择？

[提示：贪婪算法在每次迭代中可能取得的最小进展是什么，作为最佳集合覆盖的大小和尚未被覆盖的元素数量的函数？]

A) $2$

B) $O(logn)$

C) $O(\sqrt n)$

D) $O(n)$

这题做不来，参考了老师的提示以及[博客](https://zjuturtle.com/2018/03/22/set-cover/)

假设最优解为$OPT$，这里的核心思路是证明在剩余$x$个元素未包含在集合内的条件下，我们的算法至少会增加$\frac {x}{OPT}$个新的元素，下面证明一下。

设$ \bigcup _{i=1}^{m}S_i=U,|U|=n$，原问题的最优解为$OPT$，假设已经选择的集合为$S_1,...,S_k$，剩余的集合为$S_{k+1},...,S_m$，记$ U_1=\bigcup _{i=1}^{k}S_i$，我们的算法实际上是找使得$ | S_i - U_1 |(i=k+1,...m)$最大的集合，所以这里构造一系列新的集合：$S_i^{'}=S_i - U_1(i=k+1,...m)， \bigcup _{i=k+1}^{m}S_i^{'}=U^{'},|U^{'}|=x$，注意这里$x$表示剩余$x$个元素未包含在集合$U$内。

假设关于$S_{k+1}^{'},...,S_m^{'}$的集合覆盖问题的最优解为$OPT^{'}$，我们显然有$OPT\ge OPT^{'}$。此外，因为$S_{k+1}^{'},...,S_m^{'}$的最优解为$OPT^{'}$，所以必然有一个集合的元素个数大于等于$\frac {x}{OPT^{'}}$，这是因为如果每个集合的元素都小于$\frac {x}{OPT^{'}}$话，那么每次新增加的元素数量必然小于$\frac {x}{OPT^{'}}$，从而经过$OPT^{'}$步得到的并集元素数量小于$\frac {x}{OPT^{'}}\times OPT^{'}=x$，这就与$OPT^{'}$为最优解相矛盾。那么由于$S_{k+1}^{'},...,S_m^{'}$内必然有一个集合的元素大于等于$\frac {x}{OPT^{'}}$，我们对这个集合采取之前的贪婪算法的第一步必然会增加大于等于$\frac {x}{OPT^{'}}$个新元素。注意我们对$S_{k+1}^{'},...,S_m^{'}$采取贪婪算法实际上也是在求解我们的原问题，所以原问题在剩余$x$个元素未包含在内的情况下，贪婪算法会选择大于等于$\frac {x}{OPT^{'}}$个新元素，由于$OPT\ge OPT^{'}$，那么$\frac {x}{OPT^{'}}\ge \frac {x}{OPT}$，最后有以下结论：

**剩余$x$个元素未包含在集合内的条件下，我们的算法至少会增加$\frac {x}{OPT}$个新的元素**

设第$k$步贪婪算法后有$f(k)$个元素，那么
$$
f(0)=n\\
f(k)\le(1-\frac 1{OPT})f(k-1)\le (1-\frac 1{OPT})^2f(k-2)...\le (1-\frac 1{OPT})^kf(0)=(1-\frac 1{OPT})^k n\\
$$
如果$(1-\frac 1{OPT})^k n\le 1​$，那么贪婪算法停止。解这个不等式可得
$$
(1-\frac 1{OPT})^k \le \frac 1 n\\
k ln(1-\frac 1{OPT}) \le -ln(n)\\
k\ge -\frac {ln(n)}{ ln(1-\frac 1{OPT})}
$$
所以$k$至少为$logn$这个数量级的，所以这题选B



##### 选择题3

假设有$m$个集合$S_1,...,S_m $，每一个集合的是一个共同集合$U$的子集。目标是选择$m$中两个集合，$S_i,S_j$，来最大化$ | S_i \cup S_j |$。一种自然的启发式方法是使用贪婪算法：（i）选择元素最多的集合$S_i$; （ii）选择$S_j$使得$ | S_i \cup S_j |$最大（即选择元素不属于$S_i$数量最大的集合）。例如，如果集合为$\{1,2\}, \{2,3\},\{3,4 \}$，那么算法可能会在第一步选择$\{1,2\}$; 如果这样做，肯定会在第二步中选择$ \{3,4 \}$。

考虑以下陈述：对于上述问题的每一个实例，上面的贪心算法选择两个集合$ S_i，S_j$使得$ | S_i \cup S_j |$至少是$c$倍最优解。以下哪一项是常数是$c$的最大值？

A) $\frac 2 3$

B) $\frac 3 4$

C) $\frac 1 2$

D) $1$



可以看到这题和上一题非常相似，这一题相当于只采用了两步上一题的贪婪算法。设上一题的贪婪算法产生的最优解为$OPT$，$ |\bigcup _{i=1}^{m}S_i|=n$。由上一题结论我们知道，两步之后最多还剩下$(1-\frac 1{OPT})^2 n$个元素，所以前两步至少选择了$n-(1-\frac 1{OPT})^2 n$个元素，设此题的全局最优解为$y$，那么$y\le n$(因为一共才$n$个元素)，从而
$$
| S_i \cup S_j |\ge n-(1-\frac 1{OPT})^2 n \ge y[1-(1-\frac 1{OPT})^2]
$$
如果$OPT\ge 2$，那么
$$
| S_i \cup S_j | \ge y[1-(1-\frac 1{OPT})^2] \ge y[1-(1-\frac 1{2})^2]=\frac 3 4 y
$$
如果$OPT=1$，那么意味着第一步会选择一个包含全部元素的集合，此时
$$
| S_i \cup S_j |=y=n
$$
综上
$$
| S_i \cup S_j | \ge \frac 3 4 y
$$
这题选B



##### 选择题4

考虑以下工作调度问题。有$m$台完全相同的机器。有$n$个工作和每个工作有大小 $p_j$。每个工作必须分配给一台机器。机器的负载是分配给它的工作大小的总和。工作分配的完成时间是机器的最大负载; 这是我们想要最小化的数量。例如，假设有两台机器和$4$个大小为$7,8,5,6$的工作。将前两个作业分配给第一台机器，将最后两个作业分配给第二台机器时，将产生机器负载$15$和$11$，使整个机器的工作时间为$15$。更好的分配是将$7,6$安排在第一台机器上，$8,5$安排在第二台机器上，完工时间为13。

考虑下面的贪婪算法。迭代工作$j=1，2，3，...，n$。在考虑工作$j$时，将其分配给当前具有最小负载的机器。例如，在上面的四个工作实例中，该算法会将第一个工作分配给第一台机器，将第二个作业分配给第二台机器，将第三个作业分配给第一台机器，将第四个作业分配给第二台机器（结果为$14$）。

考虑以下陈述：对于每个这样的工作调度实例，这个贪婪算法得到的解最多为 $C$乘以最优（最小完工时间）工作分配的时间。$C$的最小值为多少？

[提示：让 $A$ 和 $B$表示平均和最大工作量（$A=\frac{\sum _{j}p_j}{m},B=max_{j}p_j$）。尝试将最优解和贪婪算法的输出结合和$A,B$联系起来]

A) $4$

B) $\frac 6 5$

C) $\frac 3 2$

D) $2$

假设最优解为$OPT$，贪婪算法的最优解为$OPT^{'}$$，那么显然$$OPT\ge A,OPT \ge B$，接下来我们证明$OPT^{'}\le A+B$，利用反证法。假设存在一台机器$x_i$的负载大于$A+B$，考虑最后一次安排在$x_i$上的任务负载$p_l$，有$B$的定义我们有$p_l\le B$，所以最后一次给$x_i$安排任务之前，$x_i$的负载大于$A$，在这时间点必然有一个机器$x_j$，它的负载小于等于$A$，所以这就与贪婪算法矛盾，从而$OPT^{'}\le A+B$。结合这几点，我们有
$$
2 OPT\ge A+B\ge OPT^{'}
$$
所以这题选D



##### 选择题5

考虑上一题的最小化工作调度问题。现在假设，在上一个问题中运行贪婪算法之前，我们首先将作业从最大到最小排序。例如，在上一个问题中讨论的四个工作实例中，工作将按顺序8,7,6,5进行考虑，然后贪婪算法会产生一个最优工作计划，其中13是完成时间。

考虑以下陈述：对于每个此类工作调度实例，贪婪算法（使用此排序预处理步骤）得到的解最多为 $C$乘以最优（最小完工时间）工作分配的时间。$C$的最小值为多少？

A) $4$

B) $2$

C) $\frac 6 5$

D) $\frac 3 2$



同样假设最优解为$OPT$，此贪婪算法产生的解为$OPT^{'}$。如果工作数量小于等于机器的数量，那么$OPT=OPT^{'}$，因为每台机器最多一个工作，此时$c=1$；如果如果工作数量大于等于机器的数量，考虑负载为$OPT^{'}$的机器安排的最后一份工作，记该工作的大小为$p_j$，那么安排$p_j$时必然每台机器至少有一个工作了，所以$p_j\le p_{m+1}$。现在考虑$OPT$，由于工作数量大于机器数量，所以$OPT$必然至少由两份工作组成，由于这里从大到小排序，所以$p_{m+1}$必然和$p_m$安排在一台机器，因此$OPT\ge p_m+p_{m+1}\ge 2p_{m+1}$，结合以上几点，我们可得最后一个安排的工作$p_j\le p_{m+1}\le \frac{OPT}{2}$。

记$A=\frac{\sum _{j}p_j}{m}$，负载为$OPT^{'}$的机器安排的最后一份工作之前，它的负载为$P$，那么$P$必然小于等于$A$。这是因为首先$m$台机器中必然有负载小于等于$A$的机器，其次贪婪算法必然选择当且负载最小的机器，所以结论成立。由上一题我们知道$A \le OPT$，所以综上
$$
OPT^{'}=p_j+P\le \frac {OPT}{2}+OPT=\frac {3}{2} OPT
$$
所以这题选D



（备注：本笔记内容均来自coursera stanford算法专项课程的内容总结）

